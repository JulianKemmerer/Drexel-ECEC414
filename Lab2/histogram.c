/* Lab 1: Histrogram generation 
 * compile as follows: gcc -o histogram histogram.c -std=c99 -lpthread -lm
 * Histogramerific!
 * reset && gcc -g -o histogramerific.wow histogram.c -std=c99 -lpthread -lm && ./histogramerific.wow 500000000
 */

#define _XOPEN_SOURCE 600 //FO BARRIERS

#include <stdlib.h>
#include <stdio.h>
#include <sys/time.h>
#include <math.h>
#include <float.h>
#include <pthread.h>

void run_test(int);
void compute_gold(int *, int *, int, int);
void compute_using_pthreads(int *, int *, int, int);

#define HISTOGRAM_SIZE 500
#define NUM_THREADS 2

//Global thread list
pthread_t thread[NUM_THREADS];
//Global list of individual thread local workspaces
int * local_histograms[NUM_THREADS];
//Set global convienient variable for number of elements
int num_elements;
//Also keep generated input data as global
int * input_data;
//Also make the variable for returning global 
//since 'compute' functions do not return values
int * histogram_using_pthreads;
//Need to ensure all threads have started before continuing
//Barrier (French: barry-yay)
//May or may not be required... technically I think yes, see report.
pthread_barrier_t barr;

////////////////////////////////////////////////////////////////////////////////
// Program main
////////////////////////////////////////////////////////////////////////////////
int 
main( int argc, char** argv) 
{
	if(argc != 2){
		printf("Usage: histogram <num elements> \n");
		exit(0);	
	}
	num_elements = atoi(argv[1]); //Removed 'int'
	run_test(num_elements);
	return 0;
}

////////////////////////////////////////////////////////////////////////////////
//! Generate the histogram on Single Threaded CPU and Then PTHREADS and Check for Correctness
////////////////////////////////////////////////////////////////////////////////
void run_test(int num_elements) 
{
	float diff;
	int i; 
	int *reference_histogram = (int *)malloc(sizeof(int) * HISTOGRAM_SIZE); // Space to store histogram generated by the CPU
	histogram_using_pthreads = (int *)malloc(sizeof(int) * HISTOGRAM_SIZE); // Space to store histogram generated by the CPU

	// Allocate memory for the input data
	int size = sizeof(int) * num_elements;
	input_data = (int *)malloc(size); //Removed 'int *'
	
	// Randomly generate input data. Initialize the input data to be integer values between 0 and (HISTOGRAM_SIZE - 1)
	for(i = 0; i < num_elements; i++)
		input_data[i] = floorf((HISTOGRAM_SIZE - 1) * (rand()/(float)RAND_MAX));

	printf("Creating the reference histogram. \n"); 
	// Compute the reference solution on the CPU
	struct timeval start, stop;	
	gettimeofday(&start, NULL);

	compute_gold(input_data, reference_histogram, num_elements, HISTOGRAM_SIZE);

	gettimeofday(&stop, NULL);
	printf("Serial CPU run time = %0.2f s. \n", (float)(stop.tv_sec - start.tv_sec + (stop.tv_usec - start.tv_usec)/(float)1000000));
	
	// Compute the histogram using pthreads. The result histogram should be stored on the histogram_using_pthreads array
	printf("\n");
	printf("Creating histogram using pthreads. \n");
	gettimeofday(&start, NULL);
	compute_using_pthreads(input_data, histogram_using_pthreads, num_elements, HISTOGRAM_SIZE);
	gettimeofday(&stop, NULL);
	printf("Parallel CPU run time = %0.2f s. \n", (float)(stop.tv_sec - start.tv_sec + (stop.tv_usec - start.tv_usec)/(float)1000000));

	// Compute the differences between the reference and pthread results
	diff = 0.0;
	for(i = 0; i < HISTOGRAM_SIZE; i++)
		diff = diff + abs(reference_histogram[i] - histogram_using_pthreads[i]);

	printf("Difference between the reference and pthread results: %f. \n", diff);
   
	// cleanup memory
	free(input_data);
	free(reference_histogram);
	free(histogram_using_pthreads);

	pthread_exit(NULL);
}

/* This function computes the reference solution. */
void compute_gold(int *input_data, int *histogram, int num_elements, int histogram_size)
{
  int i;
  
  // Initialize histogram
  for(i = 0; i < histogram_size; i++) 
			 histogram[i] = 0; 

  // Bin the elements in the input stream
  for(i = 0; i < num_elements; i++)
			 histogram[input_data[i]]++;
}


void * thread_function(void * thread_id)
{
	//Get id, gives warning but whatevski
	int id = (int)thread_id;
	
	//First thing sync for all threads to have started
	//printf("%d at barrier\n",id);
    //pthread_barrier_wait(&barr); //MIGHT NOT NEED?
	
	//Allocate a local histogram to record results in
	int * my_local_histogram_not_yours_man = (int *)malloc(sizeof(int) * HISTOGRAM_SIZE);
	//Put this info in the global table
	local_histograms[id] = my_local_histogram_not_yours_man;
	
	//Initialize that localgram yo!
	int i;
	for(i = 0; i < HISTOGRAM_SIZE; i++)
	{   //Curly Braces for President!
		my_local_histogram_not_yours_man[i] = 0;
	}
	
	//Do my histogram work
	//Size of my chunk is determined by:
	//number of threads
	//size of data
	//thread id
	//DIVVVYY THAT ARRAAY UUUPP
	int chunk_size = ceil( (double)num_elements / (double)NUM_THREADS);
	int start_bound = id * chunk_size;
	int end_bound = start_bound + chunk_size - 1;
	//TAKE CARE OF THAT END CASE
	if(id==NUM_THREADS-1)
	{
		end_bound = num_elements-1;
	}
	
	//Actual WORK
	//Bin the elements
	for(i = start_bound; i <= end_bound; i++)
	{	//Curly Braces for President!
		my_local_histogram_not_yours_man[input_data[i]]++;
	}
	
	//Now we can finish out life as a thread.
	//Long live this thread.	
	//Try to join to other threads under some conditions
	//TREE CONDITIONS
	int max_joins = log2(NUM_THREADS);
	int join_index = 0;
	for(join_index=0; join_index < max_joins; join_index++)
	{
		//If your id mod join_index (roughly) == 0  then join
		if(id % (int)pow(2,join_index+1) ==0)
		{
			//Yes join this time
			int join_to = id + pow(2,join_index);
			//printf("ID: %d, Joining to: %d \n", id,join_to);
			pthread_join(thread[join_to], NULL);
			
			//Since that thread just finished, merge it's data into mine.
			//Look up threads storage location
			int * other_threads_histogram = local_histograms[join_to];
			//printf("id %d, other_threads_histogram %d\n", id, other_threads_histogram);
			
			//Add the results of the other histogram to my own
			for(i = 0; i < HISTOGRAM_SIZE; i++)
			{   //Curly Braces for President!
				my_local_histogram_not_yours_man[i] += other_threads_histogram[i];
			}
			
		}
		else
		{
			//NO JOINS FOR YOU? STOP HERE!
			pthread_exit(NULL);
		}
	}
}


// Write the function to compute the histogram using pthreads
void compute_using_pthreads(int *input_data, int *histogram, int num_elements, int histogram_size)
{
	//Init barrier
	//May not actually be needed, ya know?
    pthread_barrier_init(&barr, NULL, NUM_THREADS);
	
	//Start threads
	int thread_id;
	for(thread_id=0; thread_id < NUM_THREADS; thread_id++)
	{
		pthread_create( &thread[thread_id], NULL, thread_function, (void*) thread_id);
	}

	//Join the first (final) thread
	pthread_join(thread[0], NULL);
	
	//Final thread's local histogram is the answer, to life, the universe, and everything.
	histogram_using_pthreads = local_histograms[0];
}



